<!doctype html>
<html lang="uk">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AST — Simple Tree</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
  body { margin:0; font-family: Arial, Helvetica, sans-serif; background:#fafafa; color:#111; }
  header { padding:12px 16px; border-bottom:1px solid #e6e6e6; display:flex; align-items:center; gap:12px; background: #fff; }
  header h1 { margin:0; font-size:16px; font-weight:600; }
  #chart { width:100%; height:calc(100vh - 49px); overflow:hidden; background: #fff; }
  .node circle { fill: #fff; stroke:#2b6cb0; stroke-width:1.6; }
  .node text { font-size:12px; fill:#111; }
  .link { fill:none; stroke:#999; stroke-width:1.2; }
  .muted { color:#666; font-size:13px; margin-left:8px; }
</style>
</head>
<body>
  <header>
    <h1>AST — simple tree</h1>
    <div class="muted">Дерево повністю розгорнуте. Використовуй колесо миші / свайп для зуму та перетягування для панорамування.</div>
  </header>

  <div id="chart"></div>

<script>
// Перетворюємо AST JSON у просту деревоподібну структуру для d3
function toTree(node) {
  if (node === null) return { name: "null" };
  if (typeof node !== "object") return { name: String(node) };
  const nodetype = node.type || "Object";
  const children = [];
  for (const key of Object.keys(node)) {
    if (key === "type") continue;
    const val = node[key];
    if (Array.isArray(val)) {
      val.forEach((c, i) => {
        if (c && typeof c === "object") children.push({ name: `${key}[${i}]`, raw: c });
        else children.push({ name: `${key}[${i}]: ${String(c)}` });
      });
    } else if (val && typeof val === "object") {
      children.push({ name: key, raw: val });
    } else {
      children.push({ name: `${key}: ${String(val)}` });
    }
  }
  const childTrees = children.map(ch => ch.raw ? toTree(ch.raw) : { name: ch.name });
  return { name: nodetype, children: childTrees.length ? childTrees : undefined, _raw: node };
}

// Асинхронне завантаження та рендер
async function loadAndRender() {
  try {
    const res = await fetch('ast.json', { cache: "no-store" });
    if (!res.ok) throw new Error('HTTP ' + res.status);
    const data = await res.json();
    const tree = toTree(data);
    render(tree);
  } catch (err) {
    document.getElementById('chart').innerHTML = '<div style="padding:20px;color:#900">Не вдалося завантажити ast.json: ' + err.message + '</div>';
    console.error(err);
  }
}

// Основний рендер (простий вертикальний tree)
function render(rootData) {
  const container = document.getElementById('chart');
  container.innerHTML = '';

  const nodeWidth = 160;
  const nodeHeight = 60;

  const root = d3.hierarchy(rootData);
  const treeLayout = d3.tree().nodeSize([nodeHeight, nodeWidth]);
  treeLayout(root);

  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  root.each(d => {
    if (d.x < minX) minX = d.x;
    if (d.x > maxX) maxX = d.x;
    if (d.y < minY) minY = d.y;
    if (d.y > maxY) maxY = d.y;
  });

  const margin = { top: 20, right: 40, bottom: 20, left: 40 };
  const width = Math.max(800, (maxY - minY) + margin.left + margin.right);
  const height = Math.max(600, (maxX - minX) + margin.top + margin.bottom);

  const svg = d3.create("svg")
    .attr("viewBox", [0, 0, width, height])
    .attr("preserveAspectRatio", "xMidYMid meet")
    .style("width", "100%")
    .style("height", "100%");

  const g = svg.append("g").attr("transform", `translate(${margin.left - minY}, ${margin.top - minX})`);

  g.append("g")
    .selectAll("path")
    .data(root.links())
    .join("path")
    .attr("class", "link")
    .attr("d", d => {
      const sx = d.source.x, sy = d.source.y;
      const tx = d.target.x, ty = d.target.y;
      return `M ${sy} ${sx} C ${sy + (ty - sy) * 0.5} ${sx}, ${ty - (ty - sy) * 0.5} ${tx}, ${ty} ${tx}`;
    })
    .attr("stroke", "#999")
    .attr("fill", "none");

  const nodeG = g.append("g")
    .selectAll("g")
    .data(root.descendants())
    .join("g")
    .attr("class", "node")
    .attr("transform", d => `translate(${d.y},${d.x})`);

  nodeG.append("circle").attr("r", 6).attr("fill", "#fff").attr("stroke", "#2b6cb0").attr("stroke-width", 1.6);

  nodeG.append("text")
    .attr("x", 10)
    .attr("y", 4)
    .text(d => d.data.name)
    .style("font-size", "12px")
    .style("fill", "#111");

  nodeG.append("title").text(d => {
    try {
      return JSON.stringify(d.data._raw || d.data, null, 2).slice(0, 800);
    } catch (e) { return d.data.name; }
  });

  const zoom = d3.zoom().scaleExtent([0.2, 3]).on("zoom", (event) => {
    g.attr("transform", event.transform);
  });
  svg.call(zoom);

  container.appendChild(svg.node());

  const initialScale = 1;
  const tx = 20;
  const ty = 0;
  svg.transition().duration(600).call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(initialScale));
}

// start
loadAndRender();
</script>
</body>
</html>